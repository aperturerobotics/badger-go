// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.6.1
// source: github.com/dgraph-io/badger/v4/pb/badgerpb4.proto

package pb

import (
	base64 "encoding/base64"
	fmt "fmt"
	io "io"
	strconv "strconv"
	strings "strings"

	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
)

//
// Copyright (C) 2017 Dgraph Labs, Inc. and Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Use protos/gen.sh to generate .pb.go files.

type EncryptionAlgo int32

const (
	EncryptionAlgo_aes EncryptionAlgo = 0
)

// Enum value maps for EncryptionAlgo.
var (
	EncryptionAlgo_name = map[int32]string{
		0: "aes",
	}
	EncryptionAlgo_value = map[string]int32{
		"aes": 0,
	}
)

func (x EncryptionAlgo) Enum() *EncryptionAlgo {
	p := new(EncryptionAlgo)
	*p = x
	return p
}

func (x EncryptionAlgo) String() string {
	name, valid := EncryptionAlgo_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type ManifestChange_Operation int32

const (
	ManifestChange_CREATE ManifestChange_Operation = 0
	ManifestChange_DELETE ManifestChange_Operation = 1
)

// Enum value maps for ManifestChange_Operation.
var (
	ManifestChange_Operation_name = map[int32]string{
		0: "CREATE",
		1: "DELETE",
	}
	ManifestChange_Operation_value = map[string]int32{
		"CREATE": 0,
		"DELETE": 1,
	}
)

func (x ManifestChange_Operation) Enum() *ManifestChange_Operation {
	p := new(ManifestChange_Operation)
	*p = x
	return p
}

func (x ManifestChange_Operation) String() string {
	name, valid := ManifestChange_Operation_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type Checksum_Algorithm int32

const (
	Checksum_CRC32C   Checksum_Algorithm = 0
	Checksum_XXHash64 Checksum_Algorithm = 1
)

// Enum value maps for Checksum_Algorithm.
var (
	Checksum_Algorithm_name = map[int32]string{
		0: "CRC32C",
		1: "XXHash64",
	}
	Checksum_Algorithm_value = map[string]int32{
		"CRC32C":   0,
		"XXHash64": 1,
	}
)

func (x Checksum_Algorithm) Enum() *Checksum_Algorithm {
	p := new(Checksum_Algorithm)
	*p = x
	return p
}

func (x Checksum_Algorithm) String() string {
	name, valid := Checksum_Algorithm_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type KV struct {
	unknownFields []byte
	Key           []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	UserMeta      []byte `protobuf:"bytes,3,opt,name=user_meta,json=userMeta,proto3" json:"userMeta,omitempty"`
	Version       uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	ExpiresAt     uint64 `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expiresAt,omitempty"`
	Meta          []byte `protobuf:"bytes,6,opt,name=meta,proto3" json:"meta,omitempty"`
	// Stream id is used to identify which stream the KV came from.
	StreamId uint32 `protobuf:"varint,10,opt,name=stream_id,json=streamId,proto3" json:"streamId,omitempty"`
	// Stream done is used to indicate end of stream.
	StreamDone bool `protobuf:"varint,11,opt,name=stream_done,json=streamDone,proto3" json:"streamDone,omitempty"`
}

func (x *KV) Reset() {
	*x = KV{}
}

func (*KV) ProtoMessage() {}

func (x *KV) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *KV) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *KV) GetUserMeta() []byte {
	if x != nil {
		return x.UserMeta
	}
	return nil
}

func (x *KV) GetVersion() uint64 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *KV) GetExpiresAt() uint64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *KV) GetMeta() []byte {
	if x != nil {
		return x.Meta
	}
	return nil
}

func (x *KV) GetStreamId() uint32 {
	if x != nil {
		return x.StreamId
	}
	return 0
}

func (x *KV) GetStreamDone() bool {
	if x != nil {
		return x.StreamDone
	}
	return false
}

type KVList struct {
	unknownFields []byte
	Kv            []*KV `protobuf:"bytes,1,rep,name=kv,proto3" json:"kv,omitempty"`
	// alloc_ref used internally for memory management.
	AllocRef uint64 `protobuf:"varint,10,opt,name=alloc_ref,json=allocRef,proto3" json:"allocRef,omitempty"`
}

func (x *KVList) Reset() {
	*x = KVList{}
}

func (*KVList) ProtoMessage() {}

func (x *KVList) GetKv() []*KV {
	if x != nil {
		return x.Kv
	}
	return nil
}

func (x *KVList) GetAllocRef() uint64 {
	if x != nil {
		return x.AllocRef
	}
	return 0
}

type ManifestChangeSet struct {
	unknownFields []byte
	// A set of changes that are applied atomically.
	Changes []*ManifestChange `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes,omitempty"`
}

func (x *ManifestChangeSet) Reset() {
	*x = ManifestChangeSet{}
}

func (*ManifestChangeSet) ProtoMessage() {}

func (x *ManifestChangeSet) GetChanges() []*ManifestChange {
	if x != nil {
		return x.Changes
	}
	return nil
}

type ManifestChange struct {
	unknownFields  []byte
	Id             uint64                   `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"` // Table ID.
	Op             ManifestChange_Operation `protobuf:"varint,2,opt,name=Op,proto3" json:"Op,omitempty"`
	Level          uint32                   `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"` // Only used for CREATE.
	KeyId          uint64                   `protobuf:"varint,4,opt,name=key_id,json=keyId,proto3" json:"keyId,omitempty"`
	EncryptionAlgo EncryptionAlgo           `protobuf:"varint,5,opt,name=encryption_algo,json=encryptionAlgo,proto3" json:"encryptionAlgo,omitempty"`
	Compression    uint32                   `protobuf:"varint,6,opt,name=compression,proto3" json:"compression,omitempty"` // Only used for CREATE Op.
}

func (x *ManifestChange) Reset() {
	*x = ManifestChange{}
}

func (*ManifestChange) ProtoMessage() {}

func (x *ManifestChange) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *ManifestChange) GetOp() ManifestChange_Operation {
	if x != nil {
		return x.Op
	}
	return ManifestChange_CREATE
}

func (x *ManifestChange) GetLevel() uint32 {
	if x != nil {
		return x.Level
	}
	return 0
}

func (x *ManifestChange) GetKeyId() uint64 {
	if x != nil {
		return x.KeyId
	}
	return 0
}

func (x *ManifestChange) GetEncryptionAlgo() EncryptionAlgo {
	if x != nil {
		return x.EncryptionAlgo
	}
	return EncryptionAlgo_aes
}

func (x *ManifestChange) GetCompression() uint32 {
	if x != nil {
		return x.Compression
	}
	return 0
}

type Checksum struct {
	unknownFields []byte
	Algo          Checksum_Algorithm `protobuf:"varint,1,opt,name=algo,proto3" json:"algo,omitempty"` // For storing type of Checksum algorithm used
	Sum           uint64             `protobuf:"varint,2,opt,name=sum,proto3" json:"sum,omitempty"`
}

func (x *Checksum) Reset() {
	*x = Checksum{}
}

func (*Checksum) ProtoMessage() {}

func (x *Checksum) GetAlgo() Checksum_Algorithm {
	if x != nil {
		return x.Algo
	}
	return Checksum_CRC32C
}

func (x *Checksum) GetSum() uint64 {
	if x != nil {
		return x.Sum
	}
	return 0
}

type DataKey struct {
	unknownFields []byte
	KeyId         uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"keyId,omitempty"`
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Iv            []byte `protobuf:"bytes,3,opt,name=iv,proto3" json:"iv,omitempty"`
	CreatedAt     int64  `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"createdAt,omitempty"`
}

func (x *DataKey) Reset() {
	*x = DataKey{}
}

func (*DataKey) ProtoMessage() {}

func (x *DataKey) GetKeyId() uint64 {
	if x != nil {
		return x.KeyId
	}
	return 0
}

func (x *DataKey) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *DataKey) GetIv() []byte {
	if x != nil {
		return x.Iv
	}
	return nil
}

func (x *DataKey) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

type Match struct {
	unknownFields []byte
	Prefix        []byte `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	IgnoreBytes   string `protobuf:"bytes,2,opt,name=ignore_bytes,json=ignoreBytes,proto3" json:"ignoreBytes,omitempty"` // Comma separated with dash to represent ranges "1, 2-3, 4-7, 9"
}

func (x *Match) Reset() {
	*x = Match{}
}

func (*Match) ProtoMessage() {}

func (x *Match) GetPrefix() []byte {
	if x != nil {
		return x.Prefix
	}
	return nil
}

func (x *Match) GetIgnoreBytes() string {
	if x != nil {
		return x.IgnoreBytes
	}
	return ""
}

func (m *KV) CloneVT() *KV {
	if m == nil {
		return (*KV)(nil)
	}
	r := new(KV)
	r.Version = m.Version
	r.ExpiresAt = m.ExpiresAt
	r.StreamId = m.StreamId
	r.StreamDone = m.StreamDone
	if rhs := m.Key; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Key = tmpBytes
	}
	if rhs := m.Value; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Value = tmpBytes
	}
	if rhs := m.UserMeta; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.UserMeta = tmpBytes
	}
	if rhs := m.Meta; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Meta = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *KV) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *KVList) CloneVT() *KVList {
	if m == nil {
		return (*KVList)(nil)
	}
	r := new(KVList)
	r.AllocRef = m.AllocRef
	if rhs := m.Kv; rhs != nil {
		tmpContainer := make([]*KV, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Kv = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *KVList) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ManifestChangeSet) CloneVT() *ManifestChangeSet {
	if m == nil {
		return (*ManifestChangeSet)(nil)
	}
	r := new(ManifestChangeSet)
	if rhs := m.Changes; rhs != nil {
		tmpContainer := make([]*ManifestChange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Changes = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ManifestChangeSet) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ManifestChange) CloneVT() *ManifestChange {
	if m == nil {
		return (*ManifestChange)(nil)
	}
	r := new(ManifestChange)
	r.Id = m.Id
	r.Op = m.Op
	r.Level = m.Level
	r.KeyId = m.KeyId
	r.EncryptionAlgo = m.EncryptionAlgo
	r.Compression = m.Compression
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ManifestChange) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Checksum) CloneVT() *Checksum {
	if m == nil {
		return (*Checksum)(nil)
	}
	r := new(Checksum)
	r.Algo = m.Algo
	r.Sum = m.Sum
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Checksum) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *DataKey) CloneVT() *DataKey {
	if m == nil {
		return (*DataKey)(nil)
	}
	r := new(DataKey)
	r.KeyId = m.KeyId
	r.CreatedAt = m.CreatedAt
	if rhs := m.Data; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Data = tmpBytes
	}
	if rhs := m.Iv; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Iv = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *DataKey) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Match) CloneVT() *Match {
	if m == nil {
		return (*Match)(nil)
	}
	r := new(Match)
	r.IgnoreBytes = m.IgnoreBytes
	if rhs := m.Prefix; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Prefix = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Match) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *KV) EqualVT(that *KV) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if string(this.Key) != string(that.Key) {
		return false
	}
	if string(this.Value) != string(that.Value) {
		return false
	}
	if string(this.UserMeta) != string(that.UserMeta) {
		return false
	}
	if this.Version != that.Version {
		return false
	}
	if this.ExpiresAt != that.ExpiresAt {
		return false
	}
	if string(this.Meta) != string(that.Meta) {
		return false
	}
	if this.StreamId != that.StreamId {
		return false
	}
	if this.StreamDone != that.StreamDone {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *KV) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*KV)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *KVList) EqualVT(that *KVList) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Kv) != len(that.Kv) {
		return false
	}
	for i, vx := range this.Kv {
		vy := that.Kv[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &KV{}
			}
			if q == nil {
				q = &KV{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.AllocRef != that.AllocRef {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *KVList) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*KVList)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ManifestChangeSet) EqualVT(that *ManifestChangeSet) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Changes) != len(that.Changes) {
		return false
	}
	for i, vx := range this.Changes {
		vy := that.Changes[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ManifestChange{}
			}
			if q == nil {
				q = &ManifestChange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ManifestChangeSet) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ManifestChangeSet)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ManifestChange) EqualVT(that *ManifestChange) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Id != that.Id {
		return false
	}
	if this.Op != that.Op {
		return false
	}
	if this.Level != that.Level {
		return false
	}
	if this.KeyId != that.KeyId {
		return false
	}
	if this.EncryptionAlgo != that.EncryptionAlgo {
		return false
	}
	if this.Compression != that.Compression {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ManifestChange) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ManifestChange)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Checksum) EqualVT(that *Checksum) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Algo != that.Algo {
		return false
	}
	if this.Sum != that.Sum {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Checksum) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Checksum)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *DataKey) EqualVT(that *DataKey) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.KeyId != that.KeyId {
		return false
	}
	if string(this.Data) != string(that.Data) {
		return false
	}
	if string(this.Iv) != string(that.Iv) {
		return false
	}
	if this.CreatedAt != that.CreatedAt {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *DataKey) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*DataKey)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Match) EqualVT(that *Match) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if string(this.Prefix) != string(that.Prefix) {
		return false
	}
	if this.IgnoreBytes != that.IgnoreBytes {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Match) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Match)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the EncryptionAlgo to JSON.
func (x EncryptionAlgo) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), EncryptionAlgo_name)
}

// MarshalText marshals the EncryptionAlgo to text.
func (x EncryptionAlgo) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), EncryptionAlgo_name)), nil
}

// MarshalJSON marshals the EncryptionAlgo to JSON.
func (x EncryptionAlgo) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EncryptionAlgo from JSON.
func (x *EncryptionAlgo) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(EncryptionAlgo_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read EncryptionAlgo enum: %v", err)
		return
	}
	*x = EncryptionAlgo(v)
}

// UnmarshalText unmarshals the EncryptionAlgo from text.
func (x *EncryptionAlgo) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), EncryptionAlgo_value)
	if err != nil {
		return err
	}
	*x = EncryptionAlgo(i)
	return nil
}

// UnmarshalJSON unmarshals the EncryptionAlgo from JSON.
func (x *EncryptionAlgo) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the KV message to JSON.
func (x *KV) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Key) > 0 || s.HasField("key") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("key")
		s.WriteBytes(x.Key)
	}
	if len(x.Value) > 0 || s.HasField("value") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("value")
		s.WriteBytes(x.Value)
	}
	if len(x.UserMeta) > 0 || s.HasField("userMeta") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("userMeta")
		s.WriteBytes(x.UserMeta)
	}
	if x.Version != 0 || s.HasField("version") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("version")
		s.WriteUint64(x.Version)
	}
	if x.ExpiresAt != 0 || s.HasField("expiresAt") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("expiresAt")
		s.WriteUint64(x.ExpiresAt)
	}
	if len(x.Meta) > 0 || s.HasField("meta") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("meta")
		s.WriteBytes(x.Meta)
	}
	if x.StreamId != 0 || s.HasField("streamId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("streamId")
		s.WriteUint32(x.StreamId)
	}
	if x.StreamDone || s.HasField("streamDone") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("streamDone")
		s.WriteBool(x.StreamDone)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the KV to JSON.
func (x *KV) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KV message from JSON.
func (x *KV) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "key":
			s.AddField("key")
			x.Key = s.ReadBytes()
		case "value":
			s.AddField("value")
			x.Value = s.ReadBytes()
		case "user_meta", "userMeta":
			s.AddField("user_meta")
			x.UserMeta = s.ReadBytes()
		case "version":
			s.AddField("version")
			x.Version = s.ReadUint64()
		case "expires_at", "expiresAt":
			s.AddField("expires_at")
			x.ExpiresAt = s.ReadUint64()
		case "meta":
			s.AddField("meta")
			x.Meta = s.ReadBytes()
		case "stream_id", "streamId":
			s.AddField("stream_id")
			x.StreamId = s.ReadUint32()
		case "stream_done", "streamDone":
			s.AddField("stream_done")
			x.StreamDone = s.ReadBool()
		}
	})
}

// UnmarshalJSON unmarshals the KV from JSON.
func (x *KV) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the KVList message to JSON.
func (x *KVList) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Kv) > 0 || s.HasField("kv") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("kv")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Kv {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("kv"))
		}
		s.WriteArrayEnd()
	}
	if x.AllocRef != 0 || s.HasField("allocRef") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("allocRef")
		s.WriteUint64(x.AllocRef)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the KVList to JSON.
func (x *KVList) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KVList message from JSON.
func (x *KVList) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "kv":
			s.AddField("kv")
			if s.ReadNil() {
				x.Kv = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Kv = append(x.Kv, nil)
					return
				}
				v := &KV{}
				v.UnmarshalProtoJSON(s.WithField("kv", false))
				if s.Err() != nil {
					return
				}
				x.Kv = append(x.Kv, v)
			})
		case "alloc_ref", "allocRef":
			s.AddField("alloc_ref")
			x.AllocRef = s.ReadUint64()
		}
	})
}

// UnmarshalJSON unmarshals the KVList from JSON.
func (x *KVList) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ManifestChangeSet message to JSON.
func (x *ManifestChangeSet) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Changes) > 0 || s.HasField("changes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("changes")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Changes {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("changes"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ManifestChangeSet to JSON.
func (x *ManifestChangeSet) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ManifestChangeSet message from JSON.
func (x *ManifestChangeSet) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "changes":
			s.AddField("changes")
			if s.ReadNil() {
				x.Changes = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Changes = append(x.Changes, nil)
					return
				}
				v := &ManifestChange{}
				v.UnmarshalProtoJSON(s.WithField("changes", false))
				if s.Err() != nil {
					return
				}
				x.Changes = append(x.Changes, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the ManifestChangeSet from JSON.
func (x *ManifestChangeSet) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ManifestChange_Operation to JSON.
func (x ManifestChange_Operation) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), ManifestChange_Operation_name)
}

// MarshalText marshals the ManifestChange_Operation to text.
func (x ManifestChange_Operation) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), ManifestChange_Operation_name)), nil
}

// MarshalJSON marshals the ManifestChange_Operation to JSON.
func (x ManifestChange_Operation) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ManifestChange_Operation from JSON.
func (x *ManifestChange_Operation) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(ManifestChange_Operation_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read Operation enum: %v", err)
		return
	}
	*x = ManifestChange_Operation(v)
}

// UnmarshalText unmarshals the ManifestChange_Operation from text.
func (x *ManifestChange_Operation) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), ManifestChange_Operation_value)
	if err != nil {
		return err
	}
	*x = ManifestChange_Operation(i)
	return nil
}

// UnmarshalJSON unmarshals the ManifestChange_Operation from JSON.
func (x *ManifestChange_Operation) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ManifestChange message to JSON.
func (x *ManifestChange) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Id != 0 || s.HasField("Id") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("Id")
		s.WriteUint64(x.Id)
	}
	if x.Op != 0 || s.HasField("Op") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("Op")
		x.Op.MarshalProtoJSON(s)
	}
	if x.Level != 0 || s.HasField("Level") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("Level")
		s.WriteUint32(x.Level)
	}
	if x.KeyId != 0 || s.HasField("keyId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyId")
		s.WriteUint64(x.KeyId)
	}
	if x.EncryptionAlgo != 0 || s.HasField("encryptionAlgo") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("encryptionAlgo")
		x.EncryptionAlgo.MarshalProtoJSON(s)
	}
	if x.Compression != 0 || s.HasField("compression") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("compression")
		s.WriteUint32(x.Compression)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ManifestChange to JSON.
func (x *ManifestChange) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ManifestChange message from JSON.
func (x *ManifestChange) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "Id":
			s.AddField("Id")
			x.Id = s.ReadUint64()
		case "Op":
			s.AddField("Op")
			x.Op.UnmarshalProtoJSON(s)
		case "Level":
			s.AddField("Level")
			x.Level = s.ReadUint32()
		case "key_id", "keyId":
			s.AddField("key_id")
			x.KeyId = s.ReadUint64()
		case "encryption_algo", "encryptionAlgo":
			s.AddField("encryption_algo")
			x.EncryptionAlgo.UnmarshalProtoJSON(s)
		case "compression":
			s.AddField("compression")
			x.Compression = s.ReadUint32()
		}
	})
}

// UnmarshalJSON unmarshals the ManifestChange from JSON.
func (x *ManifestChange) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Checksum_Algorithm to JSON.
func (x Checksum_Algorithm) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), Checksum_Algorithm_name)
}

// MarshalText marshals the Checksum_Algorithm to text.
func (x Checksum_Algorithm) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), Checksum_Algorithm_name)), nil
}

// MarshalJSON marshals the Checksum_Algorithm to JSON.
func (x Checksum_Algorithm) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Checksum_Algorithm from JSON.
func (x *Checksum_Algorithm) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(Checksum_Algorithm_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read Algorithm enum: %v", err)
		return
	}
	*x = Checksum_Algorithm(v)
}

// UnmarshalText unmarshals the Checksum_Algorithm from text.
func (x *Checksum_Algorithm) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), Checksum_Algorithm_value)
	if err != nil {
		return err
	}
	*x = Checksum_Algorithm(i)
	return nil
}

// UnmarshalJSON unmarshals the Checksum_Algorithm from JSON.
func (x *Checksum_Algorithm) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Checksum message to JSON.
func (x *Checksum) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Algo != 0 || s.HasField("algo") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("algo")
		x.Algo.MarshalProtoJSON(s)
	}
	if x.Sum != 0 || s.HasField("sum") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("sum")
		s.WriteUint64(x.Sum)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Checksum to JSON.
func (x *Checksum) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Checksum message from JSON.
func (x *Checksum) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "algo":
			s.AddField("algo")
			x.Algo.UnmarshalProtoJSON(s)
		case "sum":
			s.AddField("sum")
			x.Sum = s.ReadUint64()
		}
	})
}

// UnmarshalJSON unmarshals the Checksum from JSON.
func (x *Checksum) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the DataKey message to JSON.
func (x *DataKey) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.KeyId != 0 || s.HasField("keyId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keyId")
		s.WriteUint64(x.KeyId)
	}
	if len(x.Data) > 0 || s.HasField("data") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("data")
		s.WriteBytes(x.Data)
	}
	if len(x.Iv) > 0 || s.HasField("iv") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("iv")
		s.WriteBytes(x.Iv)
	}
	if x.CreatedAt != 0 || s.HasField("createdAt") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("createdAt")
		s.WriteInt64(x.CreatedAt)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the DataKey to JSON.
func (x *DataKey) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the DataKey message from JSON.
func (x *DataKey) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "key_id", "keyId":
			s.AddField("key_id")
			x.KeyId = s.ReadUint64()
		case "data":
			s.AddField("data")
			x.Data = s.ReadBytes()
		case "iv":
			s.AddField("iv")
			x.Iv = s.ReadBytes()
		case "created_at", "createdAt":
			s.AddField("created_at")
			x.CreatedAt = s.ReadInt64()
		}
	})
}

// UnmarshalJSON unmarshals the DataKey from JSON.
func (x *DataKey) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the Match message to JSON.
func (x *Match) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Prefix) > 0 || s.HasField("prefix") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("prefix")
		s.WriteBytes(x.Prefix)
	}
	if x.IgnoreBytes != "" || s.HasField("ignoreBytes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("ignoreBytes")
		s.WriteString(x.IgnoreBytes)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Match to JSON.
func (x *Match) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Match message from JSON.
func (x *Match) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "prefix":
			s.AddField("prefix")
			x.Prefix = s.ReadBytes()
		case "ignore_bytes", "ignoreBytes":
			s.AddField("ignore_bytes")
			x.IgnoreBytes = s.ReadString()
		}
	})
}

// UnmarshalJSON unmarshals the Match from JSON.
func (x *Match) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

func (m *KV) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KV) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *KV) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.StreamDone {
		i--
		if m.StreamDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.StreamId != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.StreamId))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x32
	}
	if m.ExpiresAt != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UserMeta) > 0 {
		i -= len(m.UserMeta)
		copy(dAtA[i:], m.UserMeta)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.UserMeta)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KVList) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVList) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *KVList) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.AllocRef != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.AllocRef))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Kv) > 0 {
		for iNdEx := len(m.Kv) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Kv[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ManifestChangeSet) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManifestChangeSet) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ManifestChangeSet) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Changes[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ManifestChange) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManifestChange) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ManifestChange) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Compression != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Compression))
		i--
		dAtA[i] = 0x30
	}
	if m.EncryptionAlgo != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.EncryptionAlgo))
		i--
		dAtA[i] = 0x28
	}
	if m.KeyId != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.KeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Op != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Checksum) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Checksum) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Checksum) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Sum != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Sum))
		i--
		dAtA[i] = 0x10
	}
	if m.Algo != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Algo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataKey) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataKey) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *DataKey) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.CreatedAt != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Iv) > 0 {
		i -= len(m.Iv)
		copy(dAtA[i:], m.Iv)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Iv)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.KeyId != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.KeyId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Match) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Match) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.IgnoreBytes) > 0 {
		i -= len(m.IgnoreBytes)
		copy(dAtA[i:], m.IgnoreBytes)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.IgnoreBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KV) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.UserMeta)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Version))
	}
	if m.ExpiresAt != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ExpiresAt))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.StreamId != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.StreamId))
	}
	if m.StreamDone {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *KVList) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kv) > 0 {
		for _, e := range m.Kv {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.AllocRef != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.AllocRef))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ManifestChangeSet) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ManifestChange) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Id))
	}
	if m.Op != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Op))
	}
	if m.Level != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Level))
	}
	if m.KeyId != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.KeyId))
	}
	if m.EncryptionAlgo != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.EncryptionAlgo))
	}
	if m.Compression != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Compression))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Checksum) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algo != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Algo))
	}
	if m.Sum != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Sum))
	}
	n += len(m.unknownFields)
	return n
}

func (m *DataKey) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.KeyId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Iv)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.CreatedAt))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Match) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.IgnoreBytes)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (x EncryptionAlgo) MarshalProtoText() string {
	return x.String()
}
func (x *KV) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("KV { ")
	if len(x.Key) > 0 {
		sb.WriteString(" key: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Key))
		sb.WriteString("\"")
	}
	if len(x.Value) > 0 {
		sb.WriteString(" value: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Value))
		sb.WriteString("\"")
	}
	if len(x.UserMeta) > 0 {
		sb.WriteString(" user_meta: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.UserMeta))
		sb.WriteString("\"")
	}
	if x.Version != 0 {
		sb.WriteString(" version: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Version), 10))
	}
	if x.ExpiresAt != 0 {
		sb.WriteString(" expires_at: ")
		sb.WriteString(strconv.FormatUint(uint64(x.ExpiresAt), 10))
	}
	if len(x.Meta) > 0 {
		sb.WriteString(" meta: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Meta))
		sb.WriteString("\"")
	}
	if x.StreamId != 0 {
		sb.WriteString(" stream_id: ")
		sb.WriteString(strconv.FormatUint(uint64(x.StreamId), 10))
	}
	if x.StreamDone {
		sb.WriteString(" stream_done: ")
		sb.WriteString(strconv.FormatBool(x.StreamDone))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *KV) String() string {
	return x.MarshalProtoText()
}
func (x *KVList) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("KVList { ")
	if len(x.Kv) > 0 {
		sb.WriteString(" kv: [")
		for i, v := range x.Kv {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.AllocRef != 0 {
		sb.WriteString(" alloc_ref: ")
		sb.WriteString(strconv.FormatUint(uint64(x.AllocRef), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *KVList) String() string {
	return x.MarshalProtoText()
}
func (x *ManifestChangeSet) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ManifestChangeSet { ")
	if len(x.Changes) > 0 {
		sb.WriteString(" changes: [")
		for i, v := range x.Changes {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ManifestChangeSet) String() string {
	return x.MarshalProtoText()
}
func (x ManifestChange_Operation) MarshalProtoText() string {
	return x.String()
}
func (x *ManifestChange) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ManifestChange { ")
	if x.Id != 0 {
		sb.WriteString(" Id: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Id), 10))
	}
	if x.Op != 0 {
		sb.WriteString(" Op: ")
		sb.WriteString(ManifestChange_Operation(x.Op).String())
	}
	if x.Level != 0 {
		sb.WriteString(" Level: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Level), 10))
	}
	if x.KeyId != 0 {
		sb.WriteString(" key_id: ")
		sb.WriteString(strconv.FormatUint(uint64(x.KeyId), 10))
	}
	if x.EncryptionAlgo != 0 {
		sb.WriteString(" encryption_algo: ")
		sb.WriteString(EncryptionAlgo(x.EncryptionAlgo).String())
	}
	if x.Compression != 0 {
		sb.WriteString(" compression: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Compression), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ManifestChange) String() string {
	return x.MarshalProtoText()
}
func (x Checksum_Algorithm) MarshalProtoText() string {
	return x.String()
}
func (x *Checksum) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Checksum { ")
	if x.Algo != 0 {
		sb.WriteString(" algo: ")
		sb.WriteString(Checksum_Algorithm(x.Algo).String())
	}
	if x.Sum != 0 {
		sb.WriteString(" sum: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Sum), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Checksum) String() string {
	return x.MarshalProtoText()
}
func (x *DataKey) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("DataKey { ")
	if x.KeyId != 0 {
		sb.WriteString(" key_id: ")
		sb.WriteString(strconv.FormatUint(uint64(x.KeyId), 10))
	}
	if len(x.Data) > 0 {
		sb.WriteString(" data: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Data))
		sb.WriteString("\"")
	}
	if len(x.Iv) > 0 {
		sb.WriteString(" iv: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Iv))
		sb.WriteString("\"")
	}
	if x.CreatedAt != 0 {
		sb.WriteString(" created_at: ")
		sb.WriteString(strconv.FormatInt(int64(x.CreatedAt), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *DataKey) String() string {
	return x.MarshalProtoText()
}
func (x *Match) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Match { ")
	if len(x.Prefix) > 0 {
		sb.WriteString(" prefix: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Prefix))
		sb.WriteString("\"")
	}
	if x.IgnoreBytes != "" {
		sb.WriteString(" ignore_bytes: ")
		sb.WriteString(strconv.Quote(x.IgnoreBytes))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Match) String() string {
	return x.MarshalProtoText()
}
func (m *KV) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMeta = append(m.UserMeta[:0], dAtA[iNdEx:postIndex]...)
			if m.UserMeta == nil {
				m.UserMeta = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = append(m.Meta[:0], dAtA[iNdEx:postIndex]...)
			if m.Meta == nil {
				m.Meta = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			m.StreamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StreamDone = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVList) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kv = append(m.Kv, &KV{})
			if err := m.Kv[len(m.Kv)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocRef", wireType)
			}
			m.AllocRef = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocRef |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManifestChangeSet) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManifestChangeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManifestChangeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, &ManifestChange{})
			if err := m.Changes[len(m.Changes)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManifestChange) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManifestChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManifestChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= ManifestChange_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgo", wireType)
			}
			m.EncryptionAlgo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionAlgo |= EncryptionAlgo(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			m.Compression = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Compression |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Checksum) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checksum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checksum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			m.Algo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algo |= Checksum_Algorithm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataKey) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iv = append(m.Iv[:0], dAtA[iNdEx:postIndex]...)
			if m.Iv == nil {
				m.Iv = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreBytes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IgnoreBytes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
